# 两次线性扫描 / 最小值传播法

## 一、适用问题类型

当问题形如：

[
res[i] = \min_j \big( val[j] + |pos[j] - i| \big)
]

并且：

* 在 **一维数组 / 直线上**
* 距离代价是 **线性的（+1 / 单位距离）**
* 求 **每个位置的最小值**

👉 可以考虑 **两次线性扫描**

典型例子：

* Codeforces E. *Air Conditioners*
* 最近火源 / 最近灯 / 最近特殊点
* “向两边扩散，代价递增 1”的问题

---

## 二、核心思想

把「**每个源点向外扩散**」
转化为「**每个位置从相邻位置继承最优值**」

### 关键转化

若当前位置 `i` 的最优值来自左侧：

```
res[i] = res[i-1] + 1
```

若来自右侧：

```
res[i] = res[i+1] + 1
```

只需：

* 一次 **左 → 右**
* 一次 **右 → 左**

即可覆盖所有可能来源。

---

## 三、算法流程

### 1️⃣ 初始化

```text
res[i] = +∞
res[a[j]] = t[j]   // 空调 / 源点
```

---

### 2️⃣ 左 → 右扫描

```rust
for i in 1..=n {
    res[i] = min(res[i], res[i-1] + 1);
}
```

含义：

* 左边位置如果更优
* 当前可以继承它 +1 的代价

---

### 3️⃣ 右 → 左扫描

```rust
for i in (1..=n).rev() {
    res[i] = min(res[i], res[i+1] + 1);
}
```

含义：

* 右边位置向左传播

---

### 4️⃣ 结果

扫描完成后：

```
res[i] = min_j (t[j] + |a[j] - i|)
```

---

## 四、为什么正确？

### 单调传播性质

* 距离代价 **严格随距离递增**
* 最近的最优源一定来自：

  * 左侧最近
  * 或右侧最近

左右各扫一次即可捕获。

---

## 五、复杂度

| 项目 | 复杂度          |
| -- | ------------ |
| 时间 | **O(n + k)** |
| 空间 | **O(n)**     |

✔ 比「每个源扩散一遍」的 O(nk) 快得多
✔ 可通过所有大数据

---

## 六、示例（Air Conditioners）

### 输入

```
n = 6
空调：
位置 2，温度 14
位置 5，温度 16
```

### 初始化

```
res = [∞, 14, ∞, ∞, 16, ∞]
```

### 左扫

```
[∞, 14, 15, 16, 16, 17]
```

### 右扫

```
[15, 14, 15, 16, 16, 17]
```

---

## 七、代码模板（Rust）

```rust
let INF = 1_000_000_000u32;
let mut res = vec![INF; n + 2];

for (a, t) in conditioners {
    res[a] = t;
}

// 左 → 右
for i in 1..=n {
    res[i] = res[i].min(res[i - 1].saturating_add(1));
}

// 右 → 左
for i in (1..=n).rev() {
    res[i] = res[i].min(res[i + 1].saturating_add(1));
}
```

---

## 八、什么时候 **不能用**

❌ 距离代价不是线性的
❌ 多维（2D / 图）
❌ 有复杂障碍 / 非连续

这种情况要：

* BFS
* Dijkstra
* 多源最短路

